<!doctype html>
<html class="no-js" lang="zh-CN" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="copyright" title="Copyright" href="../copyright.html" /><link rel="next" title="6.13 数据的累加与统计操作" href="p13_summarizing_and_perform_statistics.html" /><link rel="prev" title="6.11 读写二进制数组数据" href="p11_read_write_binary_arrays_of_structures.html" />

    <!-- Generated with Sphinx 8.1.3 and Furo 2024.08.06 -->
        <title>6.12 读取嵌套和可变长二进制数据 - python3-cookbook 3.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">python3-cookbook 3.0.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">python3-cookbook 3.0.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../copyright.html">Copyright</a></li>
<li class="toctree-l1"><a class="reference internal" href="../preface.html">前言</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p01_data_structures_algorithms.html">第一章：数据结构和算法</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of 第一章：数据结构和算法</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c01/p01_unpack_sequence_into_separate_variables.html">1.1 将序列分解为单独的变量</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p02_unpack_elements_from_iterables.html">1.2 解压可迭代对象赋值给多个变量</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p03_keep_last_n_items.html">1.3 保留最后 N 个元素</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p04_find_largest_or_smallest_n_items.html">1.4 查找最大或最小的 N 个元素</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p05_implement_a_priority_queue.html">1.5 实现一个优先级队列</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p06_map_keys_to_multiple_values_in_dict.html">1.6 字典中的键映射多个值</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p07_keep_dict_in_order.html">1.7 字典排序</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p08_calculating_with_dict.html">1.8 字典的运算</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p09_find_commonalities_in_dicts.html">1.9 查找两字典的相同点</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p10_remove_duplicates_from_seq_order.html">1.10 删除序列相同元素并保持顺序</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p11_naming_slice.html">1.11 命名切片</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p12_determine_most_freqently_items_in_seq.html">1.12 序列中出现次数最多的元素</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p13_sort_list_of_dicts_by_key.html">1.13 通过某个关键字排序一个字典列表</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p14_sort_objects_without_compare_support.html">1.14 排序不支持原生比较的对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p15_group_records_based_on_field.html">1.15 通过某个字段将记录分组</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p16_filter_sequence_elements.html">1.16 过滤序列元素</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p17_extract_subset_of_dict.html">1.17 从字典中提取子集</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p18_map_names_to_sequence_elements.html">1.18 映射名称到序列元素</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p19_transform_and_reduce_data_same_time.html">1.19 转换并同时计算数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c01/p20_combine_multiple_map_to_single_map.html">1.20 合并多个字典或映射</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p02_strings_and_text.html">第二章：字符串和文本</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of 第二章：字符串和文本</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c02/p01_split_string_on_multiple_delimiters.html">2.1 使用多个界定符分割字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p02_match_text_at_start_end.html">2.2 字符串开头或结尾匹配</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p03_match_strings_with_shell_wildcard.html">2.3 用Shell通配符匹配字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p04_match_and_search_text.html">2.4 字符串匹配和搜索</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p05_search_and_replace_text.html">2.5 字符串搜索和替换</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p06_search_replace_case_insensitive.html">2.6 字符串忽略大小写的搜索替换</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p07_specify_regexp_for_shortest_match.html">2.7 最短匹配模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p08_regexp_for_multiline_partterns.html">2.8 多行匹配模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p09_normalize_unicode_text_to_regexp.html">2.9 将Unicode文本标准化</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p10_work_with_unicode_in_regexp.html">2.10 在正则式中使用Unicode</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p11_strip_unwanted_characters.html">2.11 删除字符串中不需要的字符</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p12_sanitizing_clean_up_text.html">2.12 审查清理文本字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p13_aligning_text_strings.html">2.13 字符串对齐</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p14_combine_and_concatenate_strings.html">2.14 合并拼接字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p15_interpolating_variables_in_strings.html">2.15 字符串中插入变量</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p16_reformat_text_to_fixed_number_columns.html">2.16 以指定列宽格式化字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p17_handle_html_xml_in_text.html">2.17 在字符串中处理html和xml</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p18_tokenizing_text.html">2.18 字符串令牌解析</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p19_writing_recursive_descent_parser.html">2.19 实现一个简单的递归下降分析器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c02/p20_perform_text_operations_on_byte_string.html">2.20 字节字符串上的字符串操作</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p03_numbers_dates_times.html">第三章：数字日期和时间</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of 第三章：数字日期和时间</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c03/p01_round_number.html">3.1 数字的四舍五入</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p02_accurate_decimal_calculations.html">3.2 执行精确的浮点数运算</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p03_format_numbers_for_output.html">3.3 数字的格式化输出</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p04_binary_octal_hexadecimal_int.html">3.4 二八十六进制整数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p05_pack_unpack_large_int_from_bytes.html">3.5 字节到大整数的打包与解包</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p06_complex_math.html">3.6 复数的数学运算</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p07_infinity_and_nan.html">3.7 无穷大与NaN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p08_calculating_with_fractions.html">3.8 分数运算</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p09_calculating_with_large_num_arrays.html">3.9 大型数组运算</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p10_matrix_and_linear_algebra_calculation.html">3.10 矩阵与线性代数运算</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p11_pick_things_at_random.html">3.11 随机选择</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p12_convert_days_to_seconds_and_others.html">3.12 基本的日期与时间转换</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p13_determine_last_friday_date.html">3.13 计算上一个周五的日期</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p14_date_range_for_current_month.html">3.14 计算当前月份的日期范围</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p15_convert_strings_into_datetimes.html">3.15 字符串转换为日期</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c03/p16_manipulate_dates_involving_timezone.html">3.16 结合时区的日期操作</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p04_iterators_and_generators.html">第四章：迭代器与生成器</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of 第四章：迭代器与生成器</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c04/p01_manually_consuming_iterator.html">4.1 手动遍历迭代器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p02_delegating_iteration.html">4.2 代理迭代</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p03_create_new_iteration_with_generators.html">4.3 使用生成器创建新的迭代模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p04_implement_iterator_protocol.html">4.4 实现迭代器协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p05_iterating_in_reverse.html">4.5 反向迭代</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p06_define_generator_func_with_extra_state.html">4.6 带有外部状态的生成器函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p07_taking_slice_of_iterator.html">4.7 迭代器切片</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p08_skip_first_part_of_iterable.html">4.8 跳过可迭代对象的开始部分</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p09_iterate_over_combination_or_permutation.html">4.9 排列组合的迭代</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p10_iterate_over_index_value_pairs_of_sequence.html">4.10 序列上索引值迭代</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p11_iterate_over_multiple_sequences_simultaneously.html">4.11 同时迭代多个序列</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p12_iterate_on_items_in_separate_containers.html">4.12 不同集合上元素的迭代</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p13_create_data_processing_pipelines.html">4.13 创建数据处理管道</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p14_flattening_nested_sequence.html">4.14 展开嵌套的序列</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p15_iterate_in_sorted_order_over_merged_sorted_iterables.html">4.15 顺序迭代合并后的排序迭代对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c04/p16_replace_infinite_while_loops_with_iterator.html">4.16 迭代器代替while无限循环</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p05_files_and_io.html">第五章：文件与IO</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of 第五章：文件与IO</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c05/p01_read_write_text_data.html">5.1 读写文本数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p02_printing_to_file.html">5.2 打印输出至文件中</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p03_print_with_different_separator_or_line_ending.html">5.3 使用其他分隔符或行终止符打印</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p04_read_write_binary_data.html">5.4 读写字节数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p05_write_to_file_not_exist.html">5.5 文件不存在才能写入</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p06_io_operations_on_string.html">5.6 字符串的I/O操作</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p07_read_write_compressed_datafiles.html">5.7 读写压缩文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p08_iterate_over_fixed_sized_records.html">5.8 固定大小记录的文件迭代</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p09_read_binary_data_into_mutable_buffer.html">5.9 读取二进制数据到可变缓冲区中</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p10_memory_mapping_binary_files.html">5.10 内存映射的二进制文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p11_manipulating_pathnames.html">5.11 文件路径名的操作</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p12_test_for_the_existence_of_file.html">5.12 测试文件是否存在</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p13_get_directory_listing.html">5.13 获取文件夹中的文件列表</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p14_bypassing_filename_encoding.html">5.14 忽略文件名编码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p15_printing_bad_filenames.html">5.15 打印不合法的文件名</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p16_add_change_encoding_of_already_open_file.html">5.16 增加或改变已打开文件的编码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p17_write_bytes_to_text_file.html">5.17 将字节写入文本文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p18_wrap_existing_file_descriptor_as_file_object.html">5.18 将文件描述符包装成文件对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p19_make_temporary_files_and_directories.html">5.19 创建临时文件和文件夹</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p20_communicating_with_serial_ports.html">5.20 与串行端口的数据通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c05/p21_serializing_python_objects.html">5.21 序列化Python对象</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="../chapters/p06_data_encoding_and_process.html">第六章：数据编码和处理</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of 第六章：数据编码和处理</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="p01_read_write_csv_data.html">6.1 读写CSV数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="p02_read-write_json_data.html">6.2 读写JSON数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="p03_parse_simple_xml_data.html">6.3 解析简单的XML数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="p04_parse_huge_xml_files_incrementally.html">6.4 增量式解析大型XML文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="p05_turning_dictionary_into_xml.html">6.5 将字典转换为XML</a></li>
<li class="toctree-l2"><a class="reference internal" href="p06_parse_modify_rewrite_xml.html">6.6 解析和修改XML</a></li>
<li class="toctree-l2"><a class="reference internal" href="p07_parse_xml_documents_with_namespaces.html">6.7 利用命名空间解析XML文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="p08_interact_with_relational_database.html">6.8 与关系型数据库的交互</a></li>
<li class="toctree-l2"><a class="reference internal" href="p09_decode_encode_hexadecimal_digits.html">6.9 编码和解码十六进制数</a></li>
<li class="toctree-l2"><a class="reference internal" href="p10_decode_encode_base64.html">6.10 编码解码Base64数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="p11_read_write_binary_arrays_of_structures.html">6.11 读写二进制数组数据</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">6.12 读取嵌套和可变长二进制数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="p13_summarizing_and_perform_statistics.html">6.13 数据的累加与统计操作</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p07_functions.html">第七章：函数</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of 第七章：函数</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c07/p01_functions_that_accept_any_number_arguments.html">7.1 可接受任意数量参数的函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c07/p02_functions_that_only_accept_keyword_arguments.html">7.2 只接受关键字参数的函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c07/p03_attach_informatinal_matadata_to_function_arguments.html">7.3 给函数参数增加元信息</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c07/p04_return_multiple_values_from_function.html">7.4 返回多个值的函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c07/p05_define_functions_with_default_arguments.html">7.5 定义有默认参数的函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c07/p06_define_anonymous_or_inline_functions.html">7.6 定义匿名或内联函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c07/p07_capturing_variables_in_anonymous_functions.html">7.7 匿名函数捕获变量值</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c07/p08_make_callable_with_fewer_arguments.html">7.8 减少可调用对象的参数个数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c07/p09_replace_single_method_classes_with_functions.html">7.9 将单方法的类转换为函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c07/p10_carry_extra_state_with_callback_functions.html">7.10 带额外状态信息的回调函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c07/p11_inline_callback_functions.html">7.11 内联回调函数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c07/p12_access_variables_defined_inside_closure.html">7.12 访问闭包中定义的变量</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p08_classes_and_objects.html">第八章：类与对象</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle navigation of 第八章：类与对象</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c08/p01_change_string_representation_of_instances.html">8.1 改变对象的字符串显示</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p02_customizing_string_formatting.html">8.2 自定义字符串的格式化</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p03_make_objects_support_context_management_protocol.html">8.3 让对象支持上下文管理协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p04_save_memory_when_create_large_number_instances.html">8.4 创建大量对象时节省内存方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p05_encapsulating_names_in_class.html">8.5 在类中封装属性名</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p06_create_managed_attributes.html">8.6 创建可管理的属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p07_calling_method_on_parent_class.html">8.7 调用父类方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p08_extending_property_in_subclass.html">8.8 子类中扩展property</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p09_create_new_kind_of_class_or_instance_attribute.html">8.9 创建新的类或实例属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p10_using_lazily_computed_properties.html">8.10 使用延迟计算属性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p11_simplify_initialization_of_data_structure.html">8.11 简化数据结构的初始化</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p12_define_interface_or_abstract_base_class.html">8.12 定义接口或者抽象基类</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p13_implementing_data_model_or_type_system.html">8.13 实现数据模型的类型约束</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p14_implementing_custom_containers.html">8.14 实现自定义容器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p15_delegating_attribute_access.html">8.15 属性的代理访问</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p16_define_more_than_one_constructor_in_class.html">8.16 在类中定义多个构造器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p17_create_instance_without_invoking_init_method.html">8.17 创建不调用init方法的实例</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p18_extending_classes_with_mixins.html">8.18 利用Mixins扩展类功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p19_implements_stateful_objects_or_state_machines.html">8.19 实现状态对象或者状态机</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p20_call_method_on_object_by_string_name.html">8.20 通过字符串调用对象方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p21_implementing_visitor_pattern.html">8.21 实现访问者模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p22_implementing_visitor_pattern_without_recursion.html">8.22 不用递归实现访问者模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p23_managing_memory_in_cyclic_data_structures.html">8.23 循环引用数据结构的内存管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p24_making_classes_support_comparison_operations.html">8.24 让类支持比较操作</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c08/p25_creating_cached_instances.html">8.25 创建缓存实例</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p09_meta_programming.html">第九章：元编程</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle navigation of 第九章：元编程</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c09/p01_put_wrapper_around_function.html">9.1 在函数上添加包装器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p02_preserve_function_metadata_when_write_decorators.html">9.2 创建装饰器时保留函数元信息</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p03_unwrapping_decorator.html">9.3 解除一个装饰器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p04_define_decorator_that_takes_arguments.html">9.4 定义一个带参数的装饰器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p05_define_decorator_with_user_adjustable_attributes.html">9.5 可自定义属性的装饰器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p06_define_decorator_that_takes_optional_argument.html">9.6 带可选参数的装饰器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p07_enforcing_type_check_on_function_using_decorator.html">9.7 利用装饰器强制函数上的类型检查</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p08_define_decorators_as_part_of_class.html">9.8 将装饰器定义为类的一部分</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p09_define_decorators_as_classes.html">9.9 将装饰器定义为类</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p10_apply_decorators_to_class_and_static_methods.html">9.10 为类和静态方法提供装饰器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p11_write_decorators_that_add_arguments_to_functions.html">9.11 装饰器为被包装函数增加参数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p12_using_decorators_to_patch_class_definitions.html">9.12 使用装饰器扩充类的功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p13_using_mataclass_to_control_instance_creation.html">9.13 使用元类控制实例的创建</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p14_capture_class_attribute_definition_order.html">9.14 捕获类的属性定义顺序</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p15_define_metaclass_that_takes_optional_arguments.html">9.15 定义有可选参数的元类</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p16_enforce_argument_signature_on_args_kwargs.html">9.16 *args和**kwargs的强制参数签名</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p17_enforce_coding_conventions_in_classes.html">9.17 在类上强制使用编程规约</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p18_define_classes_programmatically.html">9.18 以编程方式定义类</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p19_initializing_class_members_at_definition_time.html">9.19 在定义的时候初始化类的成员</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p20_implement_multiple_dispatch_with_function_annotations.html">9.20 利用函数注解实现方法重载</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p21_avoid_repetitive_property_methods.html">9.21 避免重复的属性方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p22_define_context_managers_the_easy_way.html">9.22 定义上下文管理器的简单方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p23_executing_code_with_local_side_effects.html">9.23 在局部变量域中执行代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p24_parse_and_analyzing_python_source.html">9.24 解析与分析Python源码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c09/p25_disassembling_python_byte_code.html">9.25 拆解Python字节码</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p10_modules_and_packages.html">第十章：模块与包</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle navigation of 第十章：模块与包</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c10/p01_make_hierarchical_package_of_modules.html">10.1 构建一个模块的层级包</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p02_control_the_import_of_everything.html">10.2 控制模块被全部导入的内容</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p03_import_submodules_by_relative_names.html">10.3 使用相对路径名导入包中子模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p04_split_module_into_multiple_files.html">10.4 将模块分割成多个文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p05_separate_directories_import_by_namespace.html">10.5 利用命名空间导入目录分散的代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p06_reloading_modules.html">10.6 重新加载模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p07_make_directory_or_zip_runnable_as_main_script.html">10.7 运行目录或压缩文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p08_read_datafile_within_package.html">10.8 读取位于包中的数据文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p09_add_directories_to_sys_path.html">10.9 将文件夹加入到sys.path</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p10_import_modules_using_name_given_in_string.html">10.10 通过字符串名导入模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p11_load_modules_from_remote_machine_by_hooks.html">10.11 通过钩子远程加载模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p12_patching_modules_on_import.html">10.12 导入模块的同时修改模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p13_installing_packages_just_for_yourself.html">10.13 安装私有的包</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p14_creating_new_python_environment.html">10.14 创建新的Python环境</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c10/p15_distributing_packages.html">10.15 分发包</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p11_network_and_web_program.html">第十一章：网络与Web编程</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle navigation of 第十一章：网络与Web编程</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c11/p01_interact_with_http_services_as_client.html">11.1 作为客户端与HTTP服务交互</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c11/p02_creating_tcp_server.html">11.2 创建TCP服务器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c11/p03_creating_udp_server.html">11.3 创建UDP服务器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c11/p04_generate_range_of_ip_addresses_from_cidr_address.html">11.4 通过CIDR地址生成对应的IP地址集</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c11/p05_creating_simple_rest_based_interface.html">11.5 创建一个简单的REST接口</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c11/p06_implement_simple_remote_procedure_call_with_xml_rpc.html">11.6 通过XML-RPC实现简单的远程调用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c11/p07_communicate_simply_between_interpreters.html">11.7 在不同的Python解释器之间交互</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c11/p08_implementing_remote_procedure_calls.html">11.8 实现远程方法调用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c11/p09_authenticating_clients_simply.html">11.9 简单的客户端认证</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c11/p10_add_ssl_to_network_services.html">11.10 在网络服务中加入SSL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c11/p11_pass_socket_file_descriptor_between_processes.html">11.11 进程间传递Socket文件描述符</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c11/p12_understanding_event_driven_io.html">11.12 理解事件驱动的IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c11/p13_sending_receiving_large_arrays.html">11.13 发送与接收大型数组</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p12_concurrency.html">第十二章：并发编程</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle navigation of 第十二章：并发编程</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c12/p01_start_stop_thread.html">12.1 启动与停止线程</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c12/p02_determining_if_thread_has_started.html">12.2 判断线程是否已经启动</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c12/p03_communicating_between_threads.html">12.3 线程间通信</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c12/p04_locking_critical_sections.html">12.4 给关键部分加锁</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c12/p05_locking_with_deadlock_avoidance.html">12.5 防止死锁的加锁机制</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c12/p06_storing_thread_specific_state.html">12.6 保存线程的状态信息</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c12/p07_creating_thread_pool.html">12.7 创建一个线程池</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c12/p08_perform_simple_parallel_programming.html">12.8 简单的并行编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c12/p09_dealing_with_gil_stop_worring_about_it.html">12.9 Python的全局锁问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c12/p10_defining_an_actor_task.html">12.10 定义一个Actor任务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c12/p11_implement_publish_subscribe_messaging.html">12.11 实现消息发布/订阅模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c12/p12_using_generators_as_alternative_to_threads.html">12.12 使用生成器代替线程</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c12/p13_polling_multiple_thread_queues.html">12.13 多个线程队列轮询</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c12/p14_launching_daemon_process_on_unix.html">12.14 在Unix系统上面启动守护进程</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p13_utility_script_and_system_manage.html">第十三章：脚本编程与系统管理</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><div class="visually-hidden">Toggle navigation of 第十三章：脚本编程与系统管理</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c13/p01_accept_input_via_redirect_pips_or_input_files.html">13.1 通过重定向/管道/文件接受输入</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p02_terminate_program_with_an_error_message.html">13.2 终止程序并给出错误信息</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p03_parsing_command_line_options.html">13.3 解析命令行选项</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p04_prompt_for_password_at_runtime.html">13.4 运行时弹出密码输入提示</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p05_getting_terminal_size.html">13.5 获取终端的大小</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p06_executing_external_command_and_get_its_output.html">13.6 执行外部命令并获取它的输出</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p07_copy_move_files_and_directories.html">13.7 复制或者移动文件和目录</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p08_creating_and_unpacking_archives.html">13.8 创建和解压归档文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p09_find_files_by_name.html">13.9 通过文件名查找文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p10_read_configuration_files.html">13.10 读取配置文件</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p11_add_logging_to_simple_scripts.html">13.11 给简单脚本增加日志功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p12_add_logging_to_libraries.html">13.12 给函数库增加日志功能</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p13_making_stopwatch_timer.html">13.13 实现一个计时器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p14_putting_limits_on_memory_and_cpu_usage.html">13.14 限制内存和CPU的使用量</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c13/p15_luanch_a_web_browser.html">13.15 启动一个WEB浏览器</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p14_test_debug_and_exceptions.html">第十四章：测试、调试和异常</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><div class="visually-hidden">Toggle navigation of 第十四章：测试、调试和异常</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c14/p01_testing_output_sent_to_stdout.html">14.1 测试stdout输出</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c14/p02_patching_objects_in_unit_tests.html">14.2 在单元测试中给对象打补丁</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c14/p03_testing_for_exceptional_conditions_in_unit_tests.html">14.3 在单元测试中测试异常情况</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c14/p04_logging_test_output_to_file.html">14.4 将测试输出用日志记录到文件中</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c14/p05_skip_or_anticipate_test_failures.html">14.5 忽略或期望测试失败</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c14/p06_handle_multiple_exceptions.html">14.6 处理多个异常</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c14/p07_catching_all_exceptions.html">14.7 捕获所有异常</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c14/p08_creating_custom_exceptions.html">14.8 创建自定义异常</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c14/p09_raise_exception_in_response_to_another_exception.html">14.9 捕获异常后抛出另外的异常</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c14/p10_reraising_the_last_exception.html">14.10 重新抛出被捕获的异常</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c14/p11_issuing_warning_messages.html">14.11 输出警告信息</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c14/p12_debugging_basic_program_crashes.html">14.12 调试基本的程序崩溃错误</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c14/p13_profiling_and_timing_your_program.html">14.13 给你的程序做性能测试</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c14/p14_make_your_program_run_faster.html">14.14 加速程序运行</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../chapters/p15_c_extensions.html">第十五章：C语言扩展</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><div class="visually-hidden">Toggle navigation of 第十五章：C语言扩展</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../c15/p01_access_ccode_using_ctypes.html">15.1 使用ctypes访问C代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p02_write_simple_c_extension_module.html">15.2 简单的C扩展模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p03_write_extension_function_operate_on_arrays.html">15.3 编写扩展函数操作数组</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p04_manage_opaque_pointers_in_c_extension_modules.html">15.4 在C扩展模块中操作隐形指针</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p05_define_and_export_c_api_from_extension_modules.html">15.5 从扩展模块中定义和导出C的API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p06_calling_python_from_c.html">15.6 从C语言中调用Python代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p07_release_the_gil_in_c_extensions.html">15.7 从C扩展中释放全局锁</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p08_mix_threads_from_c_and_python.html">15.8 C和Python中的线程混用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p09_wrap_c_code_with_swig.html">15.9 用SWIG包装C代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p10_wrap_existing_c_code_with_cython.html">15.10 用Cython包装C代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p11_use_cython_to_write_high_performance_array_operation.html">15.11 用Cython写高性能的数组操作</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p12_turning_function_pointer_into_callable.html">15.12 将函数指针转换为可调用对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p13_pass_null_terminated_string_to_c_libraries.html">15.13 传递NULL结尾的字符串给C函数库</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p14_pass_unicode_strings_to_c_libraries.html">15.14 传递Unicode字符串给C函数库</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p15_converting_c_string_to_python.html">15.15 C字符串转换为Python字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p16_work_with_c_strings_of_dubious_encoding.html">15.16 不确定编码格式的C字符串</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p17_pass_filenames_to_c_extensions.html">15.17 传递文件名给C扩展</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p18_pass_open_files_to_c_extensions.html">15.18 传递已打开的文件给C扩展</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p19_read_file_like_objects_from_c.html">15.19 从C语言中读取类文件对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p20_consuming_an_iterable_from_c.html">15.20 处理C语言中的可迭代对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="../c15/p21_diagnosing_segmentation_faults.html">15.21 诊断分段错误</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/p16_appendix.html">附录A</a></li>
<li class="toctree-l1"><a class="reference internal" href="../aboutme.html">关于译者</a></li>
<li class="toctree-l1"><a class="reference internal" href="../roadmap.html">Roadmap</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../_sources/c06/p12_read_nested_and_variable_sized_binary_structures.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="id1">
<h1>6.12 读取嵌套和可变长二进制数据<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h1>
<section id="id2">
<h2>问题<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h2>
<p>你需要读取包含嵌套或者可变长记录集合的复杂二进制格式的数据。这些数据可能包含图片、视频、电子地图文件等。</p>
</section>
<section id="id3">
<h2>解决方案<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">struct</span></code> 模块可被用来编码/解码几乎所有类型的二进制的数据结构。为了解释清楚这种数据，假设你用下面的Python数据结构
来表示一个组成一系列多边形的点的集合：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">polys</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span> <span class="p">],</span>
    <span class="p">[</span> <span class="p">(</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">),</span> <span class="p">(</span><span class="mf">5.1</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">7.5</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">)</span> <span class="p">],</span>
    <span class="p">[</span> <span class="p">(</span><span class="mf">3.4</span><span class="p">,</span> <span class="mf">6.3</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="p">(</span><span class="mf">4.6</span><span class="p">,</span> <span class="mf">9.2</span><span class="p">)</span> <span class="p">],</span>
<span class="p">]</span>
</pre></div>
</div>
<p>现在假设这个数据被编码到一个以下列头部开始的二进制文件中去了：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">+------+--------+------------------------------------+</span>
<span class="o">|</span><span class="n">Byte</span>  <span class="o">|</span> <span class="n">Type</span>   <span class="o">|</span>  <span class="n">Description</span>                       <span class="o">|</span>
<span class="o">+======+========+====================================+</span>
<span class="o">|</span><span class="mi">0</span>     <span class="o">|</span> <span class="nb">int</span>    <span class="o">|</span>  <span class="n">文件代码</span><span class="err">（</span><span class="mh">0x1234</span><span class="err">，</span><span class="n">小端</span><span class="err">）</span>          <span class="o">|</span>
<span class="o">+------+--------+------------------------------------+</span>
<span class="o">|</span><span class="mi">4</span>     <span class="o">|</span> <span class="n">double</span> <span class="o">|</span>  <span class="n">x</span> <span class="n">的最小值</span><span class="err">（</span><span class="n">小端</span><span class="err">）</span>                <span class="o">|</span>
<span class="o">+------+--------+------------------------------------+</span>
<span class="o">|</span><span class="mi">12</span>    <span class="o">|</span> <span class="n">double</span> <span class="o">|</span>  <span class="n">y</span> <span class="n">的最小值</span><span class="err">（</span><span class="n">小端</span><span class="err">）</span>                <span class="o">|</span>
<span class="o">+------+--------+------------------------------------+</span>
<span class="o">|</span><span class="mi">20</span>    <span class="o">|</span> <span class="n">double</span> <span class="o">|</span>  <span class="n">x</span> <span class="n">的最大值</span><span class="err">（</span><span class="n">小端</span><span class="err">）</span>                <span class="o">|</span>
<span class="o">+------+--------+------------------------------------+</span>
<span class="o">|</span><span class="mi">28</span>    <span class="o">|</span> <span class="n">double</span> <span class="o">|</span>  <span class="n">y</span> <span class="n">的最大值</span><span class="err">（</span><span class="n">小端</span><span class="err">）</span>                <span class="o">|</span>
<span class="o">+------+--------+------------------------------------+</span>
<span class="o">|</span><span class="mi">36</span>    <span class="o">|</span> <span class="nb">int</span>    <span class="o">|</span>  <span class="n">三角形数量</span><span class="err">（</span><span class="n">小端</span><span class="err">）</span>                <span class="o">|</span>
<span class="o">+------+--------+------------------------------------+</span>
</pre></div>
</div>
<p>紧跟着头部是一系列的多边形记录，编码格式如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">+------+--------+-------------------------------------------+</span>
<span class="o">|</span><span class="n">Byte</span>  <span class="o">|</span> <span class="n">Type</span>   <span class="o">|</span>  <span class="n">Description</span>                              <span class="o">|</span>
<span class="o">+======+========+===========================================+</span>
<span class="o">|</span><span class="mi">0</span>     <span class="o">|</span> <span class="nb">int</span>    <span class="o">|</span>  <span class="n">记录长度</span><span class="err">（</span><span class="n">N字节</span><span class="err">）</span>                        <span class="o">|</span>
<span class="o">+------+--------+-------------------------------------------+</span>
<span class="o">|</span><span class="mi">4</span><span class="o">-</span><span class="n">N</span>   <span class="o">|</span> <span class="n">Points</span> <span class="o">|</span>  <span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span> <span class="n">坐标</span><span class="err">，</span><span class="n">以浮点数表示</span>                 <span class="o">|</span>
<span class="o">+------+--------+-------------------------------------------+</span>
</pre></div>
</div>
<p>为了写这样的文件，你可以使用如下的Python代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="k">def</span> <span class="nf">write_polys</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">polys</span><span class="p">):</span>
    <span class="c1"># Determine bounding box</span>
    <span class="n">flattened</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">polys</span><span class="p">))</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">flattened</span><span class="p">)</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">flattened</span><span class="p">)</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">flattened</span><span class="p">)</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">flattened</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;iddddi&#39;</span><span class="p">,</span> <span class="mh">0x1234</span><span class="p">,</span>
                            <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span>
                            <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">*</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="s1">&#39;&lt;dd&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;&lt;dd&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">pt</span><span class="p">))</span>
</pre></div>
</div>
<p>将数据读取回来的时候，可以利用函数 <code class="docutils literal notranslate"><span class="pre">struct.unpack()</span></code> ，代码很相似，基本就是上面写操作的逆序。如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">read_polys</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Read the header</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
        <span class="n">file_code</span><span class="p">,</span> <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">,</span> <span class="n">num_polys</span> <span class="o">=</span> \
            <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;iddddi&#39;</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_polys</span><span class="p">):</span>
            <span class="n">pbytes</span><span class="p">,</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pbytes</span> <span class="o">//</span> <span class="mi">16</span><span class="p">):</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;dd&#39;</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
                <span class="n">poly</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">polys</span>
</pre></div>
</div>
<p>尽管这个代码可以工作，但是里面混杂了很多读取、解包数据结构和其他细节的代码。如果用这样的代码来处理真实的数据文件，
那未免也太繁杂了点。因此很显然应该有另一种解决方法可以简化这些步骤，让程序员只关注自最重要的事情。</p>
<p>在本小节接下来的部分，我会逐步演示一个更加优秀的解析字节数据的方案。
目标是可以给程序员提供一个高级的文件格式化方法，并简化读取和解包数据的细节。但是我要先提醒你，
本小节接下来的部分代码应该是整本书中最复杂最高级的例子，使用了大量的面向对象编程和元编程技术。
一定要仔细的阅读我们的讨论部分，另外也要参考下其他章节内容。</p>
<p>首先，当读取字节数据的时候，通常在文件开始部分会包含文件头和其他的数据结构。
尽管struct模块可以解包这些数据到一个元组中去，另外一种表示这种信息的方式就是使用一个类。
就像下面这样：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">struct</span>

<span class="k">class</span> <span class="nc">StructField</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Descriptor representing a simple structure field</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="nb">format</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">_buffer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">r</span>

<span class="k">class</span> <span class="nc">Structure</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bytedata</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">bytedata</span><span class="p">)</span>
</pre></div>
</div>
<p>这里我们使用了一个描述器来表示每个结构字段，每个描述器包含一个结构兼容格式的代码以及一个字节偏移量，
存储在内部的内存缓冲中。在 <code class="docutils literal notranslate"><span class="pre">__get__()</span></code> 方法中，<code class="docutils literal notranslate"><span class="pre">struct.unpack_from()</span></code>
函数被用来从缓冲中解包一个值，省去了额外的分片或复制操作步骤。</p>
<p><code class="docutils literal notranslate"><span class="pre">Structure</span></code> 类就是一个基础类，接受字节数据并存储在内部的内存缓冲中，并被 <code class="docutils literal notranslate"><span class="pre">StructField</span></code> 描述器使用。
这里使用了 <code class="docutils literal notranslate"><span class="pre">memoryview()</span></code> ，我们会在后面详细讲解它是用来干嘛的。</p>
<p>使用这个代码，你现在就能定义一个高层次的结构对象来表示上面表格信息所期望的文件格式。例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PolyHeader</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">file_code</span> <span class="o">=</span> <span class="n">StructField</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="n">StructField</span><span class="p">(</span><span class="s1">&#39;&lt;d&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="n">StructField</span><span class="p">(</span><span class="s1">&#39;&lt;d&#39;</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="n">StructField</span><span class="p">(</span><span class="s1">&#39;&lt;d&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="n">StructField</span><span class="p">(</span><span class="s1">&#39;&lt;d&#39;</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
    <span class="n">num_polys</span> <span class="o">=</span> <span class="n">StructField</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="mi">36</span><span class="p">)</span>
</pre></div>
</div>
<p>下面的例子利用这个类来读取之前我们写入的多边形数据的头部数据：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;polys.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span> <span class="o">=</span> <span class="n">PolyHeader</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">file_code</span> <span class="o">==</span> <span class="mh">0x1234</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min_x</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min_y</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">max_x</span>
<span class="go">7.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">max_y</span>
<span class="go">9.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">num_polys</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>这个很有趣，不过这种方式还是有一些烦人的地方。首先，尽管你获得了一个类接口的便利，
但是这个代码还是有点臃肿，还需要使用者指定很多底层的细节(比如重复使用 <code class="docutils literal notranslate"><span class="pre">StructField</span></code> ，指定偏移量等)。
另外，返回的结果类同样确实一些便利的方法来计算结构的总数。</p>
<p>任何时候只要你遇到了像这样冗余的类定义，你应该考虑下使用类装饰器或元类。
元类有一个特性就是它能够被用来填充许多低层的实现细节，从而释放使用者的负担。
下面我来举个例子，使用元类稍微改造下我们的 <code class="docutils literal notranslate"><span class="pre">Structure</span></code> 类：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StructureMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Metaclass that automatically creates StructField descriptors</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_fields_&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">byte_order</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="nb">format</span><span class="p">,</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">format</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span><span class="s1">&#39;!&#39;</span><span class="p">,</span><span class="s1">&#39;@&#39;</span><span class="p">)):</span>
                <span class="n">byte_order</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="n">byte_order</span> <span class="o">+</span> <span class="nb">format</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">StructField</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="nb">format</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;struct_size&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Structure</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">StructureMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bytedata</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">bytedata</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">struct_size</span><span class="p">))</span>
</pre></div>
</div>
<p>使用新的 <code class="docutils literal notranslate"><span class="pre">Structure</span></code> 类，你可以像下面这样定义一个结构：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PolyHeader</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="s1">&#39;file_code&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;min_x&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;min_y&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;max_x&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;max_y&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;num_polys&#39;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>正如你所见，这样写就简单多了。我们添加的类方法 <code class="docutils literal notranslate"><span class="pre">from_file()</span></code>
让我们在不需要知道任何数据的大小和结构的情况下就能轻松的从文件中读取数据。比如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;polys.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span> <span class="o">=</span> <span class="n">PolyHeader</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">file_code</span> <span class="o">==</span> <span class="mh">0x1234</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min_x</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min_y</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">max_x</span>
<span class="go">7.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">max_y</span>
<span class="go">9.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">num_polys</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>一旦你开始使用了元类，你就可以让它变得更加智能。例如，假设你还想支持嵌套的字节结构，
下面是对前面元类的一个小的改进，提供了一个新的辅助描述器来达到想要的效果：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NestedStruct</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Descriptor representing a nested structure</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">struct_type</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">struct_type</span> <span class="o">=</span> <span class="n">struct_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">struct_type</span><span class="o">.</span><span class="n">struct_size</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">struct_type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># Save resulting structure back on instance to avoid</span>
            <span class="c1"># further recomputation of this step</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

<span class="k">class</span> <span class="nc">StructureMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Metaclass that automatically creates StructField descriptors</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clsname</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">clsdict</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_fields_&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">byte_order</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="nb">format</span><span class="p">,</span> <span class="n">fieldname</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">StructureMeta</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span>
                        <span class="n">NestedStruct</span><span class="p">(</span><span class="n">fieldname</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="nb">format</span><span class="o">.</span><span class="n">struct_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">format</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span><span class="s1">&#39;!&#39;</span><span class="p">,</span><span class="s1">&#39;@&#39;</span><span class="p">)):</span>
                    <span class="n">byte_order</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="nb">format</span> <span class="o">=</span> <span class="n">byte_order</span> <span class="o">+</span> <span class="nb">format</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fieldname</span><span class="p">,</span> <span class="n">StructField</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="nb">format</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;struct_size&#39;</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p>在这段代码中，<code class="docutils literal notranslate"><span class="pre">NestedStruct</span></code> 描述器被用来叠加另外一个定义在某个内存区域上的结构。
它通过将原始内存缓冲进行切片操作后实例化给定的结构类型。由于底层的内存缓冲区是通过一个内存视图初始化的，
所以这种切片操作不会引发任何的额外的内存复制。相反，它仅仅就是之前的内存的一个叠加而已。
另外，为了防止重复实例化，通过使用和8.10小节同样的技术，描述器保存了该实例中的内部结构对象。</p>
<p>使用这个新的修正版，你就可以像下面这样编写：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;&lt;d&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="p">]</span>

<span class="k">class</span> <span class="nc">PolyHeader</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="s1">&#39;file_code&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">),</span> <span class="c1"># nested struct</span>
        <span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">),</span> <span class="c1"># nested struct</span>
        <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;num_polys&#39;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>令人惊讶的是，它也能按照预期的正常工作，我们实际操作下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;polys.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span> <span class="o">=</span> <span class="n">PolyHeader</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">file_code</span> <span class="o">==</span> <span class="mh">0x1234</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min</span> <span class="c1"># Nested structure</span>
<span class="go">&lt;__main__.Point object at 0x1006a48d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span>
<span class="go">7.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span>
<span class="go">9.2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">num_polys</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>到目前为止，一个处理定长记录的框架已经写好了。但是如果组件记录是变长的呢？
比如，多边形文件包含变长的部分。</p>
<p>一种方案是写一个类来表示字节数据，同时写一个工具函数来通过多少方式解析内容。跟6.11小节的代码很类似：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SizedRecord</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bytedata</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">bytedata</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">size_fmt</span><span class="p">,</span> <span class="n">includes_size</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">sz_nbytes</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="n">size_fmt</span><span class="p">)</span>
        <span class="n">sz_bytes</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">sz_nbytes</span><span class="p">)</span>
        <span class="n">sz</span><span class="p">,</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">size_fmt</span><span class="p">,</span> <span class="n">sz_bytes</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">sz</span> <span class="o">-</span> <span class="n">includes_size</span> <span class="o">*</span> <span class="n">sz_nbytes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iter_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">Struct</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">off</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">s</span><span class="o">.</span><span class="n">unpack_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">,</span> <span class="n">off</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">StructureMeta</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">struct_size</span>
            <span class="k">for</span> <span class="n">off</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">),</span> <span class="n">size</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">off</span><span class="p">:</span><span class="n">off</span><span class="o">+</span><span class="n">size</span><span class="p">]</span>
                <span class="k">yield</span> <span class="n">code</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>类方法 <code class="docutils literal notranslate"><span class="pre">SizedRecord.from_file()</span></code> 是一个工具，用来从一个文件中读取带大小前缀的数据块，
这也是很多文件格式常用的方式。作为输入，它接受一个包含大小编码的结构格式编码，并且也是自己形式。
可选的 <code class="docutils literal notranslate"><span class="pre">includes_size</span></code> 参数指定了字节数是否包含头部大小。
下面是一个例子教你怎样使用从多边形文件中读取单独的多边形数据：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;polys.bin&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span> <span class="o">=</span> <span class="n">PolyHeader</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phead</span><span class="o">.</span><span class="n">num_polys</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polydata</span> <span class="o">=</span> <span class="p">[</span> <span class="n">SizedRecord</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;&lt;i&#39;</span><span class="p">)</span>
<span class="gp">... </span>            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">phead</span><span class="o">.</span><span class="n">num_polys</span><span class="p">)</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polydata</span>
<span class="go">[&lt;__main__.SizedRecord object at 0x1006a4d50&gt;,</span>
<span class="go">&lt;__main__.SizedRecord object at 0x1006a4f50&gt;,</span>
<span class="go">&lt;__main__.SizedRecord object at 0x10070da90&gt;]</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>可以看出，<code class="docutils literal notranslate"><span class="pre">SizedRecord</span></code> 实例的内容还没有被解析出来。
可以使用 <code class="docutils literal notranslate"><span class="pre">iter_as()</span></code> 方法来达到目的，这个方法接受一个结构格式化编码或者是 <code class="docutils literal notranslate"><span class="pre">Structure</span></code> 类作为输入。
这样子可以很灵活的去解析数据，例如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polydata</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Polygon&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">iter_as</span><span class="p">(</span><span class="s1">&#39;&lt;dd&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Polygon 0</span>
<span class="go">(1.0, 2.5)</span>
<span class="go">(3.5, 4.0)</span>
<span class="go">(2.5, 1.5)</span>
<span class="go">Polygon 1</span>
<span class="go">(7.0, 1.2)</span>
<span class="go">(5.1, 3.0)</span>
<span class="go">(0.5, 7.5)</span>
<span class="go">(0.8, 9.0)</span>
<span class="go">Polygon 2</span>
<span class="go">(3.4, 6.3)</span>
<span class="go">(1.2, 0.5)</span>
<span class="go">(4.6, 9.2)</span>
<span class="gp">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polydata</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Polygon&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">iter_as</span><span class="p">(</span><span class="n">Point</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Polygon 0</span>
<span class="go">1.0 2.5</span>
<span class="go">3.5 4.0</span>
<span class="go">2.5 1.5</span>
<span class="go">Polygon 1</span>
<span class="go">7.0 1.2</span>
<span class="go">5.1 3.0</span>
<span class="go">0.5 7.5</span>
<span class="go">0.8 9.0</span>
<span class="go">Polygon 2</span>
<span class="go">3.4 6.3</span>
<span class="go">1.2 0.5</span>
<span class="go">4.6 9.2</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>将所有这些结合起来，下面是一个 <code class="docutils literal notranslate"><span class="pre">read_polys()</span></code> 函数的另外一个修正版：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;&lt;d&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="p">]</span>

<span class="k">class</span> <span class="nc">PolyHeader</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="s1">&#39;file_code&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;num_polys&#39;</span><span class="p">)</span>
    <span class="p">]</span>

<span class="k">def</span> <span class="nf">read_polys</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">phead</span> <span class="o">=</span> <span class="n">PolyHeader</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">phead</span><span class="o">.</span><span class="n">num_polys</span><span class="p">):</span>
            <span class="n">rec</span> <span class="o">=</span> <span class="n">SizedRecord</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;&lt;i&#39;</span><span class="p">)</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">rec</span><span class="o">.</span><span class="n">iter_as</span><span class="p">(</span><span class="n">Point</span><span class="p">)</span> <span class="p">]</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">polys</span>
</pre></div>
</div>
</section>
<section id="id4">
<h2>讨论<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h2>
<p>这一节向你展示了许多高级的编程技术，包括描述器，延迟计算，元类，类变量和内存视图。
然而，它们都为了同一个特定的目标服务。</p>
<p>上面的实现的一个主要特征是它是基于懒解包的思想。当一个 <code class="docutils literal notranslate"><span class="pre">Structure</span></code> 实例被创建时，
<code class="docutils literal notranslate"><span class="pre">__init__()</span></code> 仅仅只是创建一个字节数据的内存视图，没有做其他任何事。
特别的，这时候并没有任何的解包或者其他与结构相关的操作发生。
这样做的一个动机是你可能仅仅只对一个字节记录的某一小部分感兴趣。我们只需要解包你需要访问的部分，而不是整个文件。</p>
<p>为了实现懒解包和打包，需要使用 <code class="docutils literal notranslate"><span class="pre">StructField</span></code> 描述器类。
用户在 <code class="docutils literal notranslate"><span class="pre">_fields_</span></code> 中列出来的每个属性都会被转化成一个 <code class="docutils literal notranslate"><span class="pre">StructField</span></code> 描述器，
它将相关结构格式码和偏移值保存到存储缓存中。元类 <code class="docutils literal notranslate"><span class="pre">StructureMeta</span></code> 在多个结构类被定义时自动创建了这些描述器。
我们使用元类的一个主要原因是它使得用户非常方便的通过一个高层描述就能指定结构格式，而无需考虑低层的细节问题。</p>
<p><code class="docutils literal notranslate"><span class="pre">StructureMeta</span></code> 的一个很微妙的地方就是它会固定字节数据顺序。
也就是说，如果任意的属性指定了一个字节顺序(&lt;表示低位优先 或者 &gt;表示高位优先)，
那后面所有字段的顺序都以这个顺序为准。这么做可以帮助避免额外输入，但是在定义的中间我们仍然可能切换顺序的。
比如，你可能有一些比较复杂的结构，就像下面这样：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ShapeFile</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;&gt;i&#39;</span><span class="p">,</span> <span class="s1">&#39;file_code&#39;</span><span class="p">),</span> <span class="c1"># Big endian</span>
        <span class="p">(</span><span class="s1">&#39;20s&#39;</span><span class="p">,</span> <span class="s1">&#39;unused&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;file_length&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="s1">&#39;version&#39;</span><span class="p">),</span> <span class="c1"># Little endian</span>
        <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;shape_type&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;min_x&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;min_y&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;max_x&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;max_y&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;min_z&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;max_z&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;min_m&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;max_m&#39;</span><span class="p">)</span> <span class="p">]</span>
</pre></div>
</div>
<p>之前我们提到过，<code class="docutils literal notranslate"><span class="pre">memoryview()</span></code> 的使用可以帮助我们避免内存的复制。
当结构存在嵌套的时候，<code class="docutils literal notranslate"><span class="pre">memoryviews</span></code> 可以叠加同一内存区域上定义的机构的不同部分。
这个特性比较微妙，但是它关注的是内存视图与普通字节数组的切片操作行为。
如果你在一个字节字符串或字节数组上执行切片操作，你通常会得到一个数据的拷贝。
而内存视图切片不是这样的，它仅仅是在已存在的内存上面叠加而已。因此，这种方式更加高效。</p>
<p>还有很多相关的章节可以帮助我们扩展这里讨论的方案。
参考8.13小节使用描述器构建一个类型系统。
8.10小节有更多关于延迟计算属性值的讨论，并且跟NestedStruct描述器的实现也有关。
9.19小节有一个使用元类来初始化类成员的例子，和 <code class="docutils literal notranslate"><span class="pre">StructureMeta</span></code> 类非常相似。
Python的 <code class="docutils literal notranslate"><span class="pre">ctypes</span></code> 源码同样也很有趣，它提供了对定义数据结构、数据结构嵌套这些相似功能的支持。</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="p13_summarizing_and_perform_statistics.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">6.13 数据的累加与统计操作</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="p11_read_write_binary_arrays_of_structures.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">6.11 读写二进制数组数据</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                <a href="../copyright.html">Copyright</a> &#169; 2017, 熊能
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">6.12 读取嵌套和可变长二进制数据</a><ul>
<li><a class="reference internal" href="#id2">问题</a></li>
<li><a class="reference internal" href="#id3">解决方案</a></li>
<li><a class="reference internal" href="#id4">讨论</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=cd91d057"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=5fa4622c"></script>
    </body>
</html>